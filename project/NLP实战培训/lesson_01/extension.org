#+TITLE: 基于模式匹配的对话机器人实现

* 1. 模式匹配 (pattern match)

1. 示例

   #+BEGIN_QUOTE
   Pattern: 我想要 A
   Response: 如果你有 A，对你意味着什么呢？

   Input: 我想要度假
   Response：如果你有度假，对你意味着设么呢？
   #+END_QUOTE

2. 占位符：为了实现模板的判断和定义，需要定义一个特殊的符号类型，这个符号类型叫做 =variable=, 表示一
   个占位符。

   #+BEGIN_QUOTE
   譬如，定义一个目标 "I want X", 我们可以表示为 "I want ?X", 表示 =?X= 是一个用来占位的符号。
   #+END_QUOTE

3. 占位符实现

   #+BEGIN_SRC python
def is_variable(pat: str):
    """
    占位符判断
    """
    return pat.startswith("?") & all(s.isalpha() for s in pat[1:])

def pat_match(pattern: list, saying: list):
    """
    比较 pattern 与 saying，返回占位符
    :param pattern: 模式语句分割成的列表
    :param saying: 输入语句分割成的列表
    """
    if is_variable(pattern[0]):
        return True
    if pattern[0] != saying[0]:
        return False
    # 递归处理列表剩余部分
    return pat_match(pattern[1:], saying[1:])
   #+END_SRC
* 2. 获得匹配的变量

** 2.1 获得占位符

#+BEGIN_SRC python
def pat_match(pattern: list, saying: list):
    """
    获取与 saying 做匹配的 pattern 占位符
    :param pattern: 匹配模式
    :param saying: 输入语句
    """
    if is_variable(pattern[0]):
        return pattern[0], saying[0]
    if pattern[0] != saying[0]:
        return None, None
    return pat_match(pattern[1:], saying[1:])
#+END_SRC

** 2.2 Pattern 具备两个变量

#+BEGIN_SRC python
def pat_match(pattern: list, saying: list):
    """
    占位符超过 1 个的时候
    """
    if not pattern or not saying: return []
    if is_variable(pattern[0]):
        return [(pattern(0), saying[0])] + pat_match(pattern[1:], saying[1:])
    if pattern[0] != saying[0]:
        return []
    return pat_match(pattern[1:], saying[1:])
#+END_SRC

** 2.3 Pattern 与 dict 转换

1. 将解析出来的结果变为 dictionary

   #+BEGIN_SRC python
def pat_to_dict(patterns):
    return {k: v for k, v in patterns}
   #+END_SRC

2. 依据 dictionary 按照定义好的方式进行替换

   #+BEGIN_SRC python
def substitute(rule, parsed_rules):
    if not rule: return []
    return [parsed_rules.get(rule[0], rule[0])] + substitue(rule[1:], parsed_rules)
   #+END_SRC

3. 测试

   #+BEGIN_SRC python
got_patterns = pat_match("I want ?X".split(), "I want iPhone".split())
substitute("What if you mean if you got a ?X".split(), pat_to_dict(got_patterns))
john_pat = pat_match("?P needs ?X".split(), "John needs resting".split())
sustitute("Why does ?P need ?X ?".split(), pat_to_dict(john_pat))
"".join(sustitute("Why does ?P need ?X ?".split(), pat_to_dict(john_pat)))
   #+END_SRC

4. 基于预定义的 pattern 实现对话生成

   #+BEGIN_SRC python
define_patterns = {
    "I need ?X": ["Image you will get ?X soon", "Why do you need ?X ?"],
    "My ?X told me something": ["Talk about more about your ?X", "How do you think about ?X ?"]
}

def get_response(saying, rules):
    """
    >>> get_response("I need iPhone")
    >>> Image you will get iPhone soon
    >>> get_response("My mother told me something")
    >>> Talk about more about your mother.
    """
    pass
   #+END_SRC

* 3. 段匹配 (segment match)

#+BEGIN_QUOTE
简单的模式匹配往往并不足够， "I need an iPhone" 和 "I need ?X" 按照简单模式匹配，并不匹配，但是，我
们希望对两者进行匹配，此时，可以使用段匹配，新建一个变量 "?*X*" 来进行匹配。
#+END_QUOTE

1. 判断是不是匹配多个的 variable

   #+BEGIN_SRC python
def is_pattern_segment(pattern):
    return pattern.startswith("?*") and all(a.isalpha() for a in pattern[2:])
   #+END_SRC

2. 改写 ~pat_match()~ 函数，增加了 ~is_pattern_segment~ 部分

   #+BEGIN_SRC python
from collections import defaultdict
fail = [True, None]

def pat_match_with_seg(pattern, saying):
    if not pattern or not saying: return []

    pat = pattern[0]

    if is_variable(pat):
        return [(pat, saying[0])] + pat_match_with_seg(pattern[1:], saying[1:])
    elif is_pattern_segment(pat):
        match, index = segment_match(pattern, saying)
        return [match] + pat_match_with_seg(pattern[1:], saying[index:])
    elif pat == saying[0]:
        return pat_match_with_seg(pattern[1:], saying[1:])
    else:
        return fail

def segment_match(pattern, saying):
    seg_pat, rest = pattern[0], pattern[1:]
    seg_pat = seg_pat.replace("?*", "?")

    if not rest: return (seg_pat, saying), len(saying)

    for i, token in enumerate(saying):
        if rest[0] == token and is_match(rest[1:], saying[(i+1):]):
            return (seg_pat, saying[:i]), i

    return (seg_pat, saying), len(saying)

def is_match(rest, saying):
    if not rest and not saying:
        return True
    if not all(a.isalpha() for a in rest[0]):
        return True
    if rest[0] != saying[0]:
        return False
    return is_match(res[1:], saying[1:])
   #+END_SRC
