
* 前言

之前曾经说过会讲如何去自行接入数据源，并基于数据源，实现盘中股票信号的更新与触发，本篇就基于此，简单
讲述一下如何接入聚宽分钟数据源，并将实时数据更新到策略类中。

* 数据源选择

目前市面上流行的量化平台很多，包括聚宽、掘金、米筐、万得等，但是基于我们需要达到的目标，即本地更新数
据，可选择的数据源就会显得受限。

1. 本地更新数据的话，需要能够得到本地接口，类似天软等数据源就被刨除
2. 如果自己维护一个小的股票池，那么剩余的一些数据接口都可以通用，但是如果想要实现全市场股票更新，某
   些数据源对于股票订阅又会有限制，此时，更优惠和便宜的选择可能只剩聚宽和免费的通达信接口。
3. 通达信接口原则上会有被封的风险，不过如果要用，目前应该还是可以做的，感兴趣的童鞋可以去 [[https://github.com/rainx/pytdx][pytdx]]
   或者 [[https://github.com/QUANTAXIS/QUANTAXIS][QUANTAXIS]] 进行具体的调研与分析，QA 可以实现全市场股票 tick 更新哦。
4. 本文笔者就简单点，直接接入聚宽的数据源，做一个全市场行情更新的 demo, 如果读者朋友还没有开通聚宽的
   本地数据权限，可以直接联系聚宽客户，用笔者的邀请码 8741, 来获得每日 1000 万得数据权限。

* 数据格式处理

虽然说股票行情其实本质上来讲比较简单，最主要的就是高开低收量，剩余的都是基于这些数据的一些变形和组合。
但是不同的数据源对于数据的封装可以会有差异，笔者简单总结可能的差异，包括：
1. 高开低收量的列名差异，如果读者朋友想要自行接入不同的数据源，就需要一个统一的列名，以方便程序的处
   理

2. 分钟行情的差异

   关于分钟行情的差异，原因多种多样，包括分钟 bar 的合成相应的时间戳不同，譬如，有的行情软件用的是第
   0 秒到第 59 秒的分笔合成，有的行情软件则是用的第 1 秒到第 60 秒的分笔合成，合成方式的不同，可能会
   导致分钟 bar 行情的差异；当然，也有可能就是行情源的数据不对，导致整体的差异，当然，在分钟级别而言，
   这样的影响其实并不大，可以忽略；此外，有一种特殊情况，笔者之前碰到过，就是在股票行情更新过程中，
   可能有一笔大单，直接将股票价格打的很高，但是很快股票价格就回到正常价格，导致如果用价格过滤器的时
   候，触发了信号，但是实际在行情软件上却什么都没有看到。

3. 接入数据

   因为聚宽的分钟行情会在每分钟开始后的第 10 秒以后才会更新，如果在之前去获取数据，拿到的就是前一分
   钟的简单复制而已，因此，读者朋友如果需要更新分钟行情，一定要注意，需要到每分钟第 10 秒之后再去获
   取行情。

4. 时间戳的设置

   因为 A 股交易时间段为工作日的 9:25 到 15:00, 而在 9:25 ~ 9:30, 14:57 ~ 15:00 是集合竞价阶段，因此，
   我们仅需要关心在 9:32 ~ 14:57 的交易行情，在程序中，可以简单加一个时间戳的判断，来避免在集合竞价
   就开始获取行情。

* 如何实现不间断获取行情

获取不间断行情最简单方式当然就是简单一个 while 循环，这个也是流行的开源数据框架，包括 vnpy 等的处理
方式，但是，我们需要注意的是，如果用 while 循环不断去对数据源进行数据请求，对方运维很可能就把你这边
的接口给断了，或者导致流量超限。

那么，一个合理的做法，因为我们做的是分钟行情更新，我们就可以每分钟去获取一次行情，如果获取失败，就重
复获取，一方面，减少了请求次数，另一方面，也降低了本地资源消耗。

* 程序实现

1. 初始化信息：包括获取全市场可交易股票信息，股票信息格式的预处理

   #+BEGIN_SRC python
def __init__(self):
    self.cursor_date = str(datetime.date.today())[:10]
    self.day_start = pd.Timestamp(self.cursor_date + " 09:32:00") # 一定需要注意在 "09:32:00" 之前留一个空格
    self.day_end = pd.Timestamp(self.cursor_date + "15:00:00")
    self.cursor_time = datetime.datetime.now()
    self.on_trade_flag = True # 是否可以交易的标志

    # 股票信息初始化
    df_stock_info = jqdatasdk.get_all_securities(types="stock").reset_index().rename(
        columns={"index": "stock_code", "display_name": "stock_name"}
    )
    df_stock_info.stock_code = df_stock_info.stock_code.map(str).str.slice(0, 6)
    self.stock_info_dict = df_stock_info.set_index("stock_code")[["stock_code"]].to_dict()["stock_name"]
   #+END_SRC

2. 绑定策略类

   #+BEGIN_SRC python
def bind_strategy(self, strategy):
    """
    将行情更新类与策略类进行绑定，实现策略类在行情更新时，实现信号的更新
    """
    self.strateg = strategy
    stock_list = self.strategy.subscribe_stocks
    self.strategy.stock_info_dict = self.stock_info_dict
    # 证券代码的格式化处理，适应聚宽的证券代码格式
    self.stock_list = list(map(lambda x: x+".XSHG" if x[0] == "6" else x + ".XSHE", stock_list))
   #+END_SRC

3. 获取分钟行情: 证券代码的分钟行情与指数行情分开获取

   #+BEGIN_SRC python
def get_min_data(self, stock_list, start_time: str, end_time: str):
        """
        DONE: 获取分钟数据

        :param stock_list: 股票池
        :param start_time: 起始时间
        :param end_time: 结束时间
        :param data_api: 数据接入接口
        :return: panel 数据格式
        e.g.
        Dimensions: 6 (items) x 2 (major_axis) x 2 (minor_axis)
        Items axis: close to volume
        Major_axis axis: 2019-01-21 10:34:00 to 2019-01-21 10:35:00
        Minor_axis axis: 600000.XSHG to 000001.XSHE
        """

        return jqdatasdk.get_price(
            security=stock_list,
            start_date=start_time,
            end_date=end_time,
            frequency="1m",
            fq="none",
        )

def get_index_min_bar(self, start_time: str, end_time: str):
    """
    接入指数行情
    """
    return jqdatasdk.get_price(
            security="000001.XSHG",
            start_date=start_time,
            end_date=end_time,
            frequency="1m",
    )
   #+END_SRC

4. 行情播放

   #+BEGIN_SRC python
def bar_play(self):
    current_time = datetime.datetime.now()
    cursor_min = current_time.minute
    while self.on_trade_flag:
        # 1. 不断获取分钟数据
        current_time = datetime.datetime.now()
        # 交易时段判断
        if current_time > self.day_end:
            self.on_trade_flag = False
        elif (not self.if_tradetime(current_time)) or (current_time.second < 10):
            # 非交易时段或者未达到行情接收时间段
            time.sleep(1.0)
            continue
        # 当分钟切换时，上根分钟结束，可以读取上个分钟 bar 数据
        curr_min_time = str(current_time - datetime.timedelta(minutes=1))[:16] + ":00"
        self.bar_time = curr_min_time[11:16]
        if current_time.minute != cursor_min:
            # 分钟切换，尝试读取新分钟数据
            print("尝试分钟切换")
            fetch_min_flag = True
            while fetch_min_flag:
                try:
                    # 注意：聚宽数据源获取的多标的行情是 panel 格式，需要转换
                    min_stock_data = self.get_min_data(
                        self.stock_list,
                        start_time = curr_min_time,
                        end_time = curr_min_time
                    ).to_frame()
                    min_stock_data = min_stock_data.reset_index().rename(
                        columns = {
                            "major": "datetime",
                            "minor": "symbol",
                        })
                    min_stock_data.symbol = min_stock_data.symbol.map(str).str.slice(0, 6)
                    min_stock_data = min_stock_data.rename(columns={"symbol": "stock_code"})
                    min_index_data = self.get_index_min_bar(
                        start_time=curr_min_time,
                        end_time=curr_min_time).reset_index().rename(columns={"index": "datetime"})
                    min_index_data["stock_code"] = "000001"

                    min_stock_data.to_csv("{}/stock_{}.csv".format(
                        self.cursor_date, curr_min_time[11:16].replace(":", "")), index=False)
                    min_index_data.to_csv("{}/index_{}.csv".format(
                        self.cursor_date, curr_min_time[11:16].replace(":", "")), index=False)
                except:
                    if current_time > self.day_end:
                        fetch_min_flag = False
                    time.sleep(1.0)
                    continue
                if len(min_stock_data) != 0 and len(min_index_data) != 0:
                    fetch_min_flag = False
                time.sleep(1.0)
                continue
            if len(min_stock_data) != 0 or len(min_index_data) != 0:
                fetch_min_flag = False
                cursor_min = current_time.minute
                min_stock_high = min_stock_data.pivot(
                                index="datetime", columns="stock_code", values="high")
                        min_stock_low = min_stock_data.pivot(
                                index="datetime", columns="stock_code", values="low")
                        min_stock_close = min_stock_data.pivot(
                                index="datetime", columns="stock_code", values="close")
                        min_stock_vol = min_stock_data.pivot(
                                index="datetime", columns="stock_code", values="volume")
                        min_stock_money = min_stock_data.pivot(
                                index="datetime", columns="stock_code", values="money")
                        min_stock_vmp = min_stock_money / min_stock_vol
                        min_index_high = min_index_data.pivot(
                                index="datetime", columns="stock_code", values="high")
                        min_index_low = min_index_data.pivot(
                                index="datetime", columns="stock_code", values="low")
                        min_index_close = min_index_data.pivot(
                                index="datetime", columns="stock_code", values="close")
                        min_bar_dict = {
                            "bar_time": self.bar_time,
                            "stock_high":
                            min_stock_high.iloc[-1].rename(
                                self.current_weekly_trade_date),
                            "stock_low":
                            min_stock_low.iloc[-1].rename(
                                self.current_weekly_trade_date),
                            "stock_close":
                            min_stock_close.iloc[-1].rename(
                                self.current_weekly_trade_date),
                            "stock_vmp":
                            min_stock_vmp.iloc[-1].rename(
                                self.current_weekly_trade_date),
                            "stock_vol":
                            min_stock_vol.iloc[-1].rename(
                                self.current_weekly_trade_date),
                            "index_high":
                            min_index_high.iloc[-1].rename(
                                self.current_weekly_trade_date),
                            "index_low":
                            min_index_low.iloc[-1].rename(
                                self.current_weekly_trade_date),
                            "index_close":
                            min_index_close.iloc[-1].rename(
                                self.current_weekly_trade_date),
                            }
                        print(min_stock_data)
                        self.strategy.on_bar(min_bar_dict)
   #+END_SRC

5. 关于策略类

   关于策略编写，我觉得先放一放，在下一次的微信公众号，看看大家的意见如何。

* 后记

笔者最近在忙着求职的事情，因为个人预期与兴趣原因，一头扎在机器学习，深度学习上，无法自拔，但是深感自
身能力有限，很想去尝试着用录播视频的方式去试着分享一下自己的学习心得等内容，不知道读者们是否感兴趣，
笔者很想基于西瓜书，机器学习实战等去试试看，感兴趣的读者请留言。
